<!DOCTYPE html>
<html>
<head>
    <title>Convex Hull Visualizer</title>
    <style>
        body { font-family: Arial; margin: 20px; background: #1e1e1e; color: #fff; }
        #canvas { border: 2px solid #444; background: #2d2d2d; cursor: crosshair; }
        button { margin: 5px; padding: 8px 16px; cursor: pointer; }
        #results { margin-top: 10px; font-family: monospace; white-space: pre; }
        .row { display: flex; gap: 20px; align-items: flex-start; }
        input { width: 80px; padding: 5px; }
    </style>
</head>
<body>
    <h2>Convex Hull - Draw or Generate Points</h2>
    <div class="row">
        <div>
            <canvas id="canvas" width="600" height="500"></canvas>
            <div>
                <button onclick="clear_all()">Clear</button>
                <button onclick="compute()">Compute Hull</button>
                <button onclick="generate()">Random</button>
                <input type="number" id="npts" value="50" min="3">
                <button onclick="exportPts()">Export</button>
                <button onclick="importPts()">Import</button>
            </div>
        </div>
        <div id="results"></div>
    </div>
    <script>
const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
let points = [], hull_graham = [], hull_dc = [];

canvas.onclick = e => {
    const r = canvas.getBoundingClientRect();
    points.push([e.clientX - r.left, e.clientY - r.top]);
    draw();
};

function draw() {
    ctx.fillStyle = '#2d2d2d'; ctx.fillRect(0, 0, 600, 500);
    ctx.fillStyle = '#4fc3f7';
    points.forEach(p => { ctx.beginPath(); ctx.arc(p[0], p[1], 4, 0, Math.PI*2); ctx.fill(); });
    if (hull_graham.length > 1) drawHull(hull_graham, '#4caf50', 2);
    if (hull_dc.length > 1) drawHull(hull_dc, '#ff9800', 4);
}

function drawHull(hull, color, width) {
    ctx.strokeStyle = color; ctx.lineWidth = width; ctx.beginPath();
    ctx.moveTo(hull[0][0], hull[0][1]);
    hull.forEach(p => ctx.lineTo(p[0], p[1]));
    ctx.closePath(); ctx.stroke();
}

function cross(o, a, b) { return (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0]); }

function graham(pts) {
    pts = [...new Set(pts.map(p => p.join(',')))].map(s => s.split(',').map(Number)).sort((a,b) => a[0]-b[0] || a[1]-b[1]);
    if (pts.length <= 1) return pts;
    let lower = [], upper = [];
    for (let p of pts) { while (lower.length >= 2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop(); lower.push(p); }
    for (let p of pts.reverse()) { while (upper.length >= 2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop(); upper.push(p); }
    return lower.slice(0, -1).concat(upper.slice(0, -1));
}

function divideConquer(pts) {
    pts = [...new Set(pts.map(p => p.join(',')))].map(s => s.split(',').map(Number)).sort((a,b) => a[0]-b[0] || a[1]-b[1]);
    if (pts.length <= 3) return graham(pts);
    
    const mid = Math.floor(pts.length / 2);
    const left = divideConquer(pts.slice(0, mid));
    const right = divideConquer(pts.slice(mid));
    
    const n1 = left.length, n2 = right.length;
    let ri = 0, li = 0;
    for (let i = 1; i < n1; i++) if (left[i][0] > left[ri][0] || (left[i][0] === left[ri][0] && left[i][1] < left[ri][1])) ri = i;
    for (let j = 1; j < n2; j++) if (right[j][0] < right[li][0] || (right[j][0] === right[li][0] && right[j][1] > right[li][1])) li = j;
    
    // Upper tangent
    let u1 = ri, u2 = li;
    while (true) {
        let moved = false;
        while (cross(left[u1], right[u2], left[(u1+1)%n1]) >= 0) {
            if (cross(left[u1], right[u2], left[(u1+1)%n1]) === 0 && left[(u1+1)%n1][1] <= left[u1][1]) break;
            u1 = (u1+1)%n1; moved = true;
        }
        while (cross(left[u1], right[u2], right[(u2-1+n2)%n2]) >= 0) {
            if (cross(left[u1], right[u2], right[(u2-1+n2)%n2]) === 0 && right[(u2-1+n2)%n2][1] <= right[u2][1]) break;
            u2 = (u2-1+n2)%n2; moved = true;
        }
        if (!moved) break;
    }
    
    // Lower tangent
    let l1 = ri, l2 = li;
    while (true) {
        let moved = false;
        while (cross(left[l1], right[l2], left[(l1-1+n1)%n1]) <= 0) {
            if (cross(left[l1], right[l2], left[(l1-1+n1)%n1]) === 0 && left[(l1-1+n1)%n1][1] >= left[l1][1]) break;
            l1 = (l1-1+n1)%n1; moved = true;
        }
        while (cross(left[l1], right[l2], right[(l2+1)%n2]) <= 0) {
            if (cross(left[l1], right[l2], right[(l2+1)%n2]) === 0 && right[(l2+1)%n2][1] >= right[l2][1]) break;
            l2 = (l2+1)%n2; moved = true;
        }
        if (!moved) break;
    }
    
    // Build merged hull
    let result = [];
    for (let i = u1; ; i = (i+1)%n1) { result.push(left[i]); if (i === l1) break; }
    for (let j = l2; ; j = (j+1)%n2) { result.push(right[j]); if (j === u2) break; }
    
    // Remove collinear
    let final = [];
    for (let p of result) {
        while (final.length >= 2 && cross(final[final.length-2], final[final.length-1], p) === 0) final.pop();
        final.push(p);
    }
    return final;
}

function compute() {
    let t1 = performance.now(); hull_graham = graham([...points]); t1 = performance.now() - t1;
    let t2 = performance.now(); hull_dc = divideConquer([...points]); t2 = performance.now() - t2;
    document.getElementById('results').textContent = 
        `Points: ${points.length}\n\nGraham (green): ${t1.toFixed(3)}ms, hull=${hull_graham.length}\nD&C (orange):   ${t2.toFixed(3)}ms, hull=${hull_dc.length}`;
    draw();
}

function generate() {
    const n = parseInt(document.getElementById('npts').value) || 50;
    points = Array.from({length: n}, () => [Math.random()*560+20, Math.random()*460+20]);
    hull_graham = []; hull_dc = []; draw();
}

function clear_all() { points = []; hull_graham = []; hull_dc = []; draw(); document.getElementById('results').textContent = ''; }

function exportPts() { navigator.clipboard.writeText(JSON.stringify(points)); alert('Copied to clipboard!'); }

function importPts() {
    const s = prompt('Paste points JSON:');
    if (s) try { points = JSON.parse(s); hull_graham = []; hull_dc = []; draw(); } catch(e) { alert('Invalid JSON'); }
}

draw();
    </script>
</body>
</html>
